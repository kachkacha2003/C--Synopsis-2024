### # თავი 4 - For, While ციკლები და Switch-Case სტრუქტურა C#-ში

## ციკლები

ციკლები C#-ში საშუალებას გვაძლევს, კოდის გარკვეული ნაწილი გავიმეოროთ, სანამ პირობა სრულდება. ეს ძალიან მოსახერხებელია განმეორებადი ოპერაციების დროს.

### 1. **For ციკლი**

**For** ციკლი გამოიყენება მაშინ, როდესაც ვიცით, რამდენჯერ უნდა შესრულდეს ციკლის ბლოკი.

**სინტაქსი**:

```csharp
for (initialization; condition; increment/decrement)
{
    // კოდი, რომელიც უნდა შესრულდეს ციკლის ყოველ ეტაპზე
}
```

**მაგალითი**:

```csharp
for (int i = 0; i < 5; i++)
{
    Console.WriteLine("რიცხვი: " + i);
}
```

ამ შემთხვევაში, ციკლი დაიწყება i = 0-დან და გაგრძელდება მანამ, სანამ i < 5 (ანუ 0-დან 4-მდე გამოიტანს რიცხვებს). ყოველ ბრუნვაზე i ერთი ერთეულით გაიზრდება (i++).

### 2. **While ციკლი**

**While** ციკლი გამოიყენება მაშინ, როდესაც არ ვიცით წინასწარ, რამდენჯერ უნდა შესრულდეს ციკლი, მაგრამ გვინდა, რომ იგი გაიმეოროს მანამ, სანამ გარკვეული პირობა იქნება ჭეშმარიტი.

**სინტაქსი**:

```csharp
while (condition)
{
    // კოდი, რომელიც უნდა შესრულდეს
}
```

**მაგალითი**:

```csharp
int i = 0;

while (i < 5)
{
    Console.WriteLine("რიცხვი: " + i);
    i++; // i-ს გაზრდა ყოველი ბრუნვის შემდეგ
}
```

ამ მაგალითში, ციკლი გაგრძელდება, სანამ i ნაკლებია 5-ზე. ყოველ ბრუნვაზე, i ერთი ერთეულით გაიზრდება (i++).

### 3. **Do-While ციკლი**

**Do-While** ციკლი მსგავსია **While** ციკლისა, მაგრამ განსხვავება ისაა, რომ კოდი ერთჯერ მაინც შესრულდება, რადგან პირობა შემოწმდება ციკლის ბოლოს.

**სინტაქსი**:

```csharp
do
{
    // კოდი, რომელიც უნდა შესრულდეს
}
while (condition);
```

**მაგალითი**:

```csharp
int i = 0;

do
{
    Console.WriteLine("რიცხვი: " + i);
    i++;
}
while (i < 5);
```

ეს კოდი მსგავსია while ციკლისა, მაგრამ ციკლი მინიმუმ ერთჯერ მაინც შესრულდება, თუნდაც პირობა თავიდანვე მცდარი იყოს.

---

## Switch-Case

**Switch-Case** სტრუქტურა გამოიყენება მაშინ, როცა გვაქვს ბევრი პირობა და გვჭირდება, რომ მათზე დაყრდნობით სხვადასხვა კოდი შესრულდეს.

**სინტაქსი**:

```csharp
switch (expression)
{
    case value1:
        // კოდი, რომელიც შესრულდება, თუ expression ტოლია value1-ს
        break;
    case value2:
        // კოდი, რომელიც შესრულდება, თუ expression ტოლია value2-ს
        break;
    default:
        // კოდი, რომელიც შესრულდება, თუ არცერთი წინა პირობა არ შეესაბამება
        break;
}
```

**მაგალითი**:

```csharp
int day = 3;

switch (day)
{
    case 1:
        Console.WriteLine("ორშაბათი");
        break;
    case 2:
        Console.WriteLine("სამშაბათი");
        break;
    case 3:
        Console.WriteLine("ოთხშაბათი");
        break;
    default:
        Console.WriteLine("უცნობი დღე");
        break;
}
```

ამ მაგალითში, თუ `day` არის 3, ეკრანზე გამოიტანს "ოთხშაბათი". თუ `day` იქნება სხვა მნიშვნელობა, შესრულდება `default` ბლოკი, რომელიც გამოტანს "უცნობი დღე".

---

## მაგალითები

### **For ციკლის მაგალითი:**

```csharp
// პირველი 10 რიცხვის ჯამი
int sum = 0;
for (int i = 1; i <= 10; i++)
{
    sum += i;
}
Console.WriteLine("პირველი 10 რიცხვის ჯამი: " + sum);
```

### **While ციკლის მაგალითი:**

```csharp
// იპოვეთ პირველი რიცხვი, რომელიც იყოფა 7-ზე
int number = 0;
while (number % 7 != 0)
{
    number++;
}
Console.WriteLine("პირველი რიცხვი, რომელიც იყოფა 7-ზე: " + number);
```

### **Switch-Case-ის მაგალითი:**

```csharp
char grade = 'B';

switch (grade)
{
    case 'A':
        Console.WriteLine("შესანიშნავია!");
        break;
    case 'B':
        Console.WriteLine("კარგია!");
        break;
    case 'C':
        Console.WriteLine("საკმარისია.");
        break;
    default:
        Console.WriteLine("უცნობი შეფასება");
        break;
}
```

---

### **დასკვნა**

- **For** ციკლი საუკეთესოა, როდესაც წინასწარ ვიცით, რამდენჯერ უნდა შესრულდეს ციკლი.
- **While** ციკლი გამოიყენება, როდესაც გვინდა, რომ ციკლი შესრულდეს მანამ, სანამ პირობა იქნება ჭეშმარიტი.
- **Do-While** ციკლი გარანტირებულად ერთხელ მაინც შეასრულებს კოდს.
- **Switch-Case** სტრუქტურა საუკეთესოა, როდესაც გვაქვს მრავალი ალტერნატიული არჩევანი, რაც შეგვიძლია გამოვიყენოთ ლოგიკის გასამარტივებლად.

ეს კონცეფციები გვთავაზობს მარტივ და ეფექტურ გზებს პროგრამის ნაკადის გასაკონტროლებლად და განმეორებითი ოპერაციების ჩასატარებლად.